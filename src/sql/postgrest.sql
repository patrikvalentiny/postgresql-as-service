-- CREATE USER  web_anon NOLOGIN;
DROP SCHEMA IF EXISTS api CASCADE;
create schema api;

grant usage on schema api to web_anon;
create table  api.todos (
  id int primary key generated by default as identity,
  done boolean not null default false,
  task text not null,
  due timestamptz
);

insert into api.todos (task) values
  ('finish tutorial 0'), ('pat self on back');
grant select on api.todos to web_anon;

DROP role IF EXISTS authenticator;
create role authenticator noinherit login password 'mysecretpassword';
grant web_anon to authenticator;

-- Create auth schema
CREATE SCHEMA IF NOT EXISTS auth;

-- Users table
CREATE TABLE IF NOT EXISTS auth.users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT UNIQUE NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    password_hash TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- JWT secrets table
CREATE TABLE IF NOT EXISTS auth.secrets (
    id SERIAL PRIMARY KEY,
    secret TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default JWT secret
INSERT INTO auth.secrets (secret) 
VALUES ('reallyreallyreallyreallyverysafe');

-- Register function
CREATE OR REPLACE FUNCTION auth.register(email TEXT, password TEXT)
RETURNS JSON AS $$
DECLARE
    user_id UUID;
    jwt_secret TEXT;
    token TEXT;
BEGIN
    -- Insert new user
    INSERT INTO auth.users (email, password_hash)
    VALUES (email, crypt(password, gen_salt('bf')))
    RETURNING id INTO user_id;
    
    -- Get JWT secret
    SELECT secret INTO jwt_secret
    FROM auth.secrets
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- Generate JWT token
    SELECT sign(
        json_build_object(
            'user_id', user_id,
            'email', email,
            'exp', extract(epoch from now() + interval '24 hours')::integer,
            'iat', extract(epoch from now())::integer
        ),
        jwt_secret
    ) INTO token;
    
    RETURN json_build_object(
        'success', true,
        'token', token,
        'user_id', user_id,
        'email', email
);
EXCEPTION
    WHEN unique_violation THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Email already exists'
        );
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Registration failed'
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Login function
CREATE OR REPLACE FUNCTION auth.login(email TEXT, password TEXT)
RETURNS JSON AS $$
DECLARE
    user_record auth.users;
    jwt_secret TEXT;
    token TEXT;
BEGIN
    -- Get user
    SELECT * INTO user_record
    FROM auth.users
    WHERE users.email = login.email;
    
    -- Check if user exists and password is correct
    IF user_record IS NULL OR user_record.password_hash != crypt(password, user_record.password_hash) THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Invalid credentials'
        );
    END IF;
    
    -- Get JWT secret
    SELECT secret INTO jwt_secret
    FROM auth.secrets
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- Generate JWT token
    SELECT sign(
        json_build_object(
            'user_id', user_record.id,
            'email', user_record.email,
            'exp', extract(epoch from now() + interval '24 hours')::integer,
            'iat', extract(epoch from now())::integer
        ),
        jwt_secret
    ) INTO token;
    
    RETURN json_build_object(
        'success', true,
        'token', token,
        'user_id', user_record.id,
        'email', user_record.email,
        'message', 'Login successful'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Verify JWT function
CREATE OR REPLACE FUNCTION auth.verify_jwt(token TEXT)
RETURNS JSON AS $$
DECLARE
    jwt_secret TEXT;
    verify_result RECORD;
BEGIN
    -- Get JWT secret
    SELECT secret INTO jwt_secret
    FROM auth.secrets
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- Verify and decode token
    SELECT * INTO verify_result
    FROM verify(token, jwt_secret);
    
    -- Check if token is valid
    IF verify_result.valid IS NOT TRUE THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Invalid token'
        );
    END IF;
    
    RETURN json_build_object(
        'success', true,
        'payload', verify_result.payload::json
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Token verification failed'
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update timestamp trigger function
CREATE OR REPLACE FUNCTION auth.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger to users table
CREATE OR REPLACE TRIGGER update_users_updated_at
    BEFORE UPDATE ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION auth.update_updated_at();

    -- Grant usage on auth schema to web_anon
    GRANT USAGE ON SCHEMA auth TO web_anon;

    -- Grant execute permissions on auth functions to web_anon
    GRANT EXECUTE ON FUNCTION auth.register(TEXT, TEXT) TO web_anon;
    GRANT EXECUTE ON FUNCTION auth.login(TEXT, TEXT) TO web_anon;
    GRANT EXECUTE ON FUNCTION auth.verify_jwt(TEXT) TO web_anon;

-- Create alcohol tracking schema
DROP SCHEMA IF EXISTS alc CASCADE;
CREATE SCHEMA alc;

-- Grant usage on alc schema to web_anon
GRANT USAGE ON SCHEMA alc TO web_anon;

-- Users table for the app (separate from auth.users for app-specific data)
CREATE TABLE alc.users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'suspended')),
    profile JSONB DEFAULT '{}'::jsonb -- avatar, preferences, optional metadata
);

-- Sessions table
CREATE TABLE alc.sessions (
    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    created_by UUID NOT NULL REFERENCES alc.users(user_id),
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    status TEXT DEFAULT 'active' CHECK (status IN ('planned', 'active', 'ended', 'cancelled')),
    details JSONB DEFAULT '{}'::jsonb -- session notes, location info, custom rules/settings
);

-- Invitations table
CREATE TABLE alc.invitations (
    invitation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES alc.sessions(session_id) ON DELETE CASCADE,
    sender_id UUID NOT NULL REFERENCES alc.users(user_id),
    recipient_id UUID NOT NULL REFERENCES alc.users(user_id),
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined')),
    sent_at TIMESTAMPTZ DEFAULT NOW(),
    responded_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb -- custom message, RSVP reason
);

-- Drink types reference table
CREATE TABLE alc.drink_types (
    drink_type_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    category TEXT NOT NULL CHECK (category IN ('alcoholic', 'soft', 'combination')),
    default_alcohol_percentage DECIMAL(5,2) DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Drinks tracking table
CREATE TABLE alc.drinks (
    drink_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES alc.sessions(session_id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES alc.users(user_id),
    drink_type_id INTEGER NOT NULL REFERENCES alc.drink_types(drink_type_id),
    amount_ml INTEGER NOT NULL CHECK (amount_ml > 0),
    added_at TIMESTAMPTZ DEFAULT NOW(),
    details JSONB DEFAULT '{}'::jsonb -- brand, notes, custom mix info, optional tags
);

-- Add update timestamp triggers
CREATE OR REPLACE FUNCTION alc.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON alc.users
    FOR EACH ROW
    EXECUTE FUNCTION alc.update_updated_at();

-- Add some default drink types
INSERT INTO alc.drink_types (name, category, default_alcohol_percentage) VALUES
    ('Beer', 'alcoholic', 5.0),
    ('Wine', 'alcoholic', 12.0),
    ('Vodka', 'alcoholic', 40.0),
    ('Whiskey', 'alcoholic', 40.0),
    ('Cocktail', 'combination', 15.0),
    ('Soda', 'soft', 0.0),
    ('Water', 'soft', 0.0),
    ('Juice', 'soft', 0.0);

-- Create row level security policies
ALTER TABLE alc.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE alc.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE alc.invitations ENABLE ROW LEVEL SECURITY;
ALTER TABLE alc.drinks ENABLE ROW LEVEL SECURITY;

-- Users can only see their own profile
CREATE POLICY users_own_data ON alc.users
    FOR ALL USING (user_id = current_setting('request.jwt.claim.user_id', true)::uuid);

-- Sessions: users can see sessions they created or are invited to
CREATE POLICY sessions_access ON alc.sessions
    FOR ALL USING (
        created_by = current_setting('request.jwt.claim.user_id', true)::uuid
        OR session_id IN (
            SELECT session_id FROM alc.invitations 
            WHERE recipient_id = current_setting('request.jwt.claim.user_id', true)::uuid 
            AND status = 'accepted'
        )
    );

-- Invitations: users can see invitations they sent or received
CREATE POLICY invitations_access ON alc.invitations
    FOR ALL USING (
        sender_id = current_setting('request.jwt.claim.user_id', true)::uuid
        OR recipient_id = current_setting('request.jwt.claim.user_id', true)::uuid
    );

-- Drinks: users can only see drinks in sessions they have access to
CREATE POLICY drinks_access ON alc.drinks
    FOR ALL USING (
        session_id IN (
            SELECT session_id FROM alc.sessions 
            WHERE created_by = current_setting('request.jwt.claim.user_id', true)::uuid
            OR session_id IN (
                SELECT session_id FROM alc.invitations 
                WHERE recipient_id = current_setting('request.jwt.claim.user_id', true)::uuid 
                AND status = 'accepted'
            )
        )
    );

-- Grant permissions to web_anon
GRANT SELECT, INSERT, UPDATE, DELETE ON alc.users TO web_anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON alc.sessions TO web_anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON alc.invitations TO web_anon;
GRANT SELECT ON alc.drink_types TO web_anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON alc.drinks TO web_anon;
GRANT USAGE ON SEQUENCE alc.drink_types_drink_type_id_seq TO web_anon;

