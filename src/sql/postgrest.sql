-- CREATE USER  web_anon NOLOGIN;
DROP SCHEMA IF EXISTS api CASCADE;
create schema api;

grant usage on schema api to web_anon;
create table  api.todos (
  id int primary key generated by default as identity,
  done boolean not null default false,
  task text not null,
  due timestamptz
);

insert into api.todos (task) values
  ('finish tutorial 0'), ('pat self on back');
grant select on api.todos to web_anon;

DROP role IF EXISTS authenticator;
create role authenticator noinherit login password 'mysecretpassword';
grant web_anon to authenticator;

-- Create auth schema
CREATE SCHEMA IF NOT EXISTS auth;

-- Users table
CREATE TABLE IF NOT EXISTS auth.users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT UNIQUE NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    password_hash TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- JWT secrets table
CREATE TABLE IF NOT EXISTS auth.secrets (
    id SERIAL PRIMARY KEY,
    secret TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default JWT secret
INSERT INTO auth.secrets (secret) 
VALUES ('reallyreallyreallyreallyverysafe');

-- Register function
CREATE OR REPLACE FUNCTION auth.register(email TEXT, password TEXT)
RETURNS JSON AS $$
DECLARE
    user_id UUID;
    jwt_secret TEXT;
    token TEXT;
BEGIN
    -- Insert new user
    INSERT INTO auth.users (email, password_hash)
    VALUES (email, crypt(password, gen_salt('bf')))
    RETURNING id INTO user_id;
    
    -- Get JWT secret
    SELECT secret INTO jwt_secret
    FROM auth.secrets
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- Generate JWT token
    SELECT sign(
        json_build_object(
            'user_id', user_id,
            'email', email,
            'exp', extract(epoch from now() + interval '24 hours')::integer,
            'iat', extract(epoch from now())::integer
        ),
        jwt_secret
    ) INTO token;
    
    RETURN json_build_object(
        'success', true,
        'token', token,
        'user_id', user_id,
        'email', email
);
EXCEPTION
    WHEN unique_violation THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Email already exists'
        );
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Registration failed'
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Login function
CREATE OR REPLACE FUNCTION auth.login(email TEXT, password TEXT)
RETURNS JSON AS $$
DECLARE
    user_record auth.users;
    jwt_secret TEXT;
    token TEXT;
BEGIN
    -- Get user
    SELECT * INTO user_record
    FROM auth.users
    WHERE users.email = login.email;
    
    -- Check if user exists and password is correct
    IF user_record IS NULL OR user_record.password_hash != crypt(password, user_record.password_hash) THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Invalid credentials'
        );
    END IF;
    
    -- Get JWT secret
    SELECT secret INTO jwt_secret
    FROM auth.secrets
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- Generate JWT token
    SELECT sign(
        json_build_object(
            'user_id', user_record.id,
            'email', user_record.email,
            'exp', extract(epoch from now() + interval '24 hours')::integer,
            'iat', extract(epoch from now())::integer
        ),
        jwt_secret
    ) INTO token;
    
    RETURN json_build_object(
        'success', true,
        'token', token,
        'user_id', user_record.id,
        'email', user_record.email,
        'message', 'Login successful'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Verify JWT function
CREATE OR REPLACE FUNCTION auth.verify_jwt(token TEXT)
RETURNS JSON AS $$
DECLARE
    jwt_secret TEXT;
    verify_result RECORD;
BEGIN
    -- Get JWT secret
    SELECT secret INTO jwt_secret
    FROM auth.secrets
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- Verify and decode token
    SELECT * INTO verify_result
    FROM verify(token, jwt_secret);
    
    -- Check if token is valid
    IF verify_result.valid IS NOT TRUE THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Invalid token'
        );
    END IF;
    
    RETURN json_build_object(
        'success', true,
        'payload', verify_result.payload::json
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'message', 'Token verification failed'
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update timestamp trigger function
CREATE OR REPLACE FUNCTION auth.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add trigger to users table
CREATE OR REPLACE TRIGGER update_users_updated_at
    BEFORE UPDATE ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION auth.update_updated_at();

    -- Grant usage on auth schema to web_anon
    GRANT USAGE ON SCHEMA auth TO web_anon;

    -- Grant execute permissions on auth functions to web_anon
    GRANT EXECUTE ON FUNCTION auth.register(TEXT, TEXT) TO web_anon;
    GRANT EXECUTE ON FUNCTION auth.login(TEXT, TEXT) TO web_anon;
    GRANT EXECUTE ON FUNCTION auth.verify_jwt(TEXT) TO web_anon;

